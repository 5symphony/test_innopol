Описание реализации

Архитектура уровней

1. Физический уровень — отдельная задача читает события UART (прерывания генерируют `uart_driver_install`) и превращает поток байтов в куски фиксированной длины. Передача работает из этой же задачи: кадр готовится заранее, дальше просто отправляем его через `uart_write_bytes`.
2. Канальный уровень — собственная задача обслуживает две очереди: из транспортного уровня получает логические сообщения и упаковывает их в кадр (`FA ll hh crc FB ... crc FE`), а из физического уровня — куски байтов, которые собирает в буфер и извлекает кадры целиком (проверяем обе CRC и стоп-байт).
3. Транспортный уровень — ещё одна задача следит за очередью исходящих запросов и отправляет их вниз, а для входящих сообщений вызывает обработчики либо разблокирует ожидающие запросы. Каждая структура `RpcMessage` содержит вложенные данные всех уровней, поэтому легко проследить путь сообщения сверху вниз и обратно.

API уровня приложения
1. Создаём `rpc::RpcProtocol` и настраиваем `RpcProtocolConfig` (порт UART, выводы, глубины очередей, таймаут ответа).
2. Вызываем `init` — драйвер UART станет генерировать события приёмника в прерывании, а все задачи запустятся автоматически.
3. Регистрируем обработчики через `registerHandler`. Функция получает буфер аргументов и должна заполнить ответ (возвращает `true` при успехе).
4. Синхронный вызов реализован методом `sendRequest`: он формирует сообщение, ждёт ответ (по номеру последовательности) и возвращает полезную нагрузку либо таймаут.

Ограничения и идеи для улучшения
- Функциональные имена ограничены 24 байтами, полезная нагрузка — 192 байтами. Для передачи больших сообщений можно расширить буферы и добавить поле «фрагмент/последний».
- Используется CRC8 как на заголовок, так и на весь кадр. Для линий с помехами лучше заменить на CRC16/CRC32.
- Обработчики хранятся в статическом массиве на 8 записей. Если нужно больше функций, стоит сделать список или таблицу с хешем имени.
- Нет повторной передачи при потере ответа. Для повышенной надёжности можно добавить счётчик ретраев и механизм подтверждений.
